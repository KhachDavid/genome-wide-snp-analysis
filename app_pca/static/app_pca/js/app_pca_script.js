/**
 * @author Outvite
 * @copyright Copyright 2022
 * @license GPL
 * @version 1.0.0
 * @host Outvite
 * @email outvite@outvite.me
 * @status development
 * @credit 1) This file was auto-generated by a bash script on Mon May  2 23:59:39 CDT 2022
 */

/**
 * Parse the user file
 * @param {user uplaoded txt or csv} file
 */
function uploadTextFile(file) {
  // analyze the file
  console.log("analyzing file...");

  // get user's file .txt
  var file = document.getElementById("text-file-input").files[0];

  // get the file reader
  var reader = new FileReader();

  // read the file
  reader.readAsText(file);

  // when the file is read
  reader.onload = function (e) {
    // get the file content
    var fileContent = reader.result;

    // get the file name
    var fileName = file.name;

    // get the file extension
    var fileExtension = fileName.split(".").pop();

    // get the file size
    var fileSize = file.size;

    // get the file type
    var fileType = file.type;

    // get the file last modified date
    var fileLastModifiedDate = file.lastModifiedDate;

    if (!checkMetaData(
      fileName,
      fileExtension,
      fileSize,
      fileType,
      fileLastModifiedDate
    )) {
      return;
    }

    // get the file content
    if (fileType === "text/plain") {
      // read txt file space separated and each line is a row
      var fileContent = fileContent.split("\n");

      // get the number of rows
      var numberOfRows = fileContent.length;

      // init the array of rows
      var rows = [];

      // split each row
      for (var i = 0; i < numberOfRows; i++) {
        // split the given row by space
        var row = fileContent[i].split(" ");

        // if this didn't work split by tab
        if (row.length === 1) {
          row = fileContent[i].split("\t");
        }

        rows.push(row);
      }

      let finalData = cleanUpData(rows);
      submitData(finalData);
    }

    if (fileType === "text/csv") {
      console.log("csv file");
      // read csv file comma separated and each line is a row
      var fileContent = fileContent.split("\n");

      // get the number of rows
      var numberOfRows = fileContent.length;

      // init the array of rows
      var rows = [];

      // split each row
      for (var i = 0; i < numberOfRows; i++) {
        // split the given row by comma
        var row = fileContent[i].split(",");

        rows.push(row);
      }

      let finalData = cleanUpData(rows);
      submitData(finalData);
    }
  };
}

/**
 * This function will take the data and decode the allele frequency
 * So, given is the GT binary form and the REF and ALT allele
 * For example REF = A and ALT = T, the encoded binary form is 0/1
 * Then if we decode this we get the allele A and the allele T
 *
 * However, if it is 1/1, then we get the allele T twice
 *
 * You can also have multiple alleles, so if it is 0/1/1, then we get the allele A and the allele T twice
 *
 * It is also possible that we have multiple alternative alleles,
 * For example Ref = A and Alt = T, C, G, the encoded binary form is 0/2
 * Then if we decode this we get the allele A and the allele C
 * If the binary form was 0/3 then we get the allele A and the allele G
 *
 * If the binary encoding is in a different format, then it is taken as -- and the allele is not decoded
 * @param {GT format (encoded in binary, mostly) allele frequency for each individual} data
 */
function cleanUpData(data) {
  var refIndex = data[0].indexOf("REF");
  var altIndex = data[0].indexOf("ALT");
  var chromIndex = data[0].indexOf("#CHROM");

  // check if chromIndex is not -1
  if (chromIndex === -1) {
    chromIndex = data[0].indexOf("CHROM");

    // check if chromIndex is not -1
    if (chromIndex === -1) {
      chromIndex = data[0].indexOf("CHROMOSOME");
    }
  }

  var posIndex = data[0].indexOf("POS");
  var idIndex = data[0].indexOf("ID");

  let columnsToKeep = [refIndex, altIndex, chromIndex, posIndex, idIndex];
  let columnsToSkip = [5, 6,7,8];
  // only including haploids and diploids
  const binaryEncodings = [
    "0/0",
    "0/1",
    "0/2",
    "0/3",
    "1/0",
    "1/1",
    "1/2",
    "1/3",
    "2/0",
    "2/1",
    "2/2",
    "2/3",
    "3/0",
    "3/1",
    "3/2",
    "3/3",
    "--",
    "0",
    "1",
    "2",
    "3",
  ];
  var returnData = "";
  // loop over each row except the first one
  for (var i = 1; i < data.length - 1; i++) {
    var row = data[i];

    var refValue = row[refIndex];
    var altValue = row[altIndex];

    // loop over the row items
    let newRow = row[chromIndex] + " " + row[idIndex] + " " + "0 " + row[posIndex] + " ";

    for (var j = 0; j < row.length; j++) {
      // if the column is not in the list of columns to keep
      if (columnsToSkip.includes(j)) {
        continue;
      }

      if (!columnsToKeep.includes(j)) {
        
        let candidateAllele = row[j];
        let new_val1;
        let new_val2;
        // check if the allele is in the binary encoding
        if (binaryEncodings.includes(candidateAllele)) {
          // if the allele is in the binary encoding, then decode it
          let new_val = decodeBinary(candidateAllele, refValue, altValue);

          new_val1 = new_val[0];
          new_val2 = new_val[1];
        } 
        else {
          new_val1 = "-";
          new_val2 = "-";
        }

        newRow += new_val1 + " " + new_val2 + " ";
      }
    }
    returnData += newRow + "\n";
  }

  // get user input value for the number of samples
  var numberOfSamples = document.getElementById("numberOfSamples").value;

  return {
    data: returnData,
    numberOfSamples: numberOfSamples,
  };

}

function decodeBinary(binaryString, ref, alt) {
  // check if alt is not a string
  if (typeof alt !== "string") {
    // convert alt to a comma separated string
    alt = alt.join(",");
  }
  let refAlt = (ref + "," + alt).split(",");
  // split the binary string by /
  var binaryArray = binaryString.split("/");
  // get the number of alleles
  var numberOfAlleles = binaryArray.length;
  // init the array of alleles
  var alleles = [];
  // loop over the alleles
  for (var i = 0; i < numberOfAlleles; i++) {
    // get the allele
    var allele = binaryArray[i];
    // if the allele is 0
    if (allele === "0") {
      // add the ref allele
      alleles.push(refAlt[0]);
    }
    // if the allele is 1
    if (allele === "1") {
      // add the alt allele
      alleles.push(refAlt[1]);
    }
    // if the allele is 2
    if (allele === "2") {
      alleles.push(refAlt[2]);
    }
    // if the allele is 3
    if (allele === "3") {
      alleles.push(refAlt[3]);
    }
  }
  // return the alleles
  return alleles
}

/**
 * Check for malicious data using the metadata of the uploaded file
 * @param {} fileName
 * @param {*} fileExtension
 * @param {*} fileSize
 * @param {*} fileType
 * @param {*} fileLastModifiedDate
 */
function checkMetaData(
  fileName,
  fileExtension,
  fileSize,
  fileType,
  fileLastModifiedDate
) {
  console.log("file name: ", fileName);
  console.log("file extension: ", fileExtension);
  console.log("file size: ", fileSize);
  console.log("file type: ", fileType);
  console.log("file last modified date: ", fileLastModifiedDate);

  if (fileSize > 320536434) {
    alert("File size is too large. Must be less than 320MB");
    return false;
  }

  return true;
}

/**
 * Send the data to the server to be processed into eigenvector and eigenvalues
 * The response would be a dictionary of various PCA results
 * @param {*} data
 */
function submitData(data) {
  // make a fetch request to the server
  let response = fetch("/pca/submit_data/", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },

    body: JSON.stringify(data),
  });

  // when the request is done
  response
    .then(function (response) {
      // get the response
      return response.json();
    })

    .then(function (response) {
      // get the response
      console.log("response: ", response);
      plotPCA(response.plotPoints, response.userPoints);
    });
}

function plotPCA(baseDataset, inputDataset) {
  // use plotly to plot the data

  let base_x = baseDataset.map(function (d) {
    return d[0];
  }, []);

  let base_y = baseDataset.map(function (d) {
    return d[1];
  }, []);

  let base_color = baseDataset.map(function (d) {
    return d[2];
  }, []);

  let base_labels = baseDataset.map(function (d) {
    return d[3];
  }, []);

  // plot the base dataset
  let base_trace = {
    x: base_x,
    y: base_y,
    mode: "markers",
    type: "scatter",
    name: "Base",
    marker: {
      color: base_color,
      size: 12,
      line: {
        color: "rgb(0, 0, 0)",
        width: 0.5,
      },
    },
    text: base_labels,
  };

  let input_x = inputDataset.map(function (d) {
    return d[0];
  }, []);

  let input_y = inputDataset.map(function (d) {
    return d[1];
  }, []);

  let input_trace = {
      
    x: input_x,
    y: input_y,
    mode: "markers",
    type: "scatter",
    name: "Input",
    color: "rgb(255, 120, 0)",
    marker: {
      color: "rgb(255, 0, 0)",
      size: 12,
      line: {
        color: "rgb(0, 0, 0)",
        width: 0.5,
      },
    },
  };

  let data = [base_trace, input_trace];

  let layout = {
    title: "PCA",
    xaxis: {
      title: "PC1",
      showgrid: true,
      zeroline: true,
      showline: true,
      autotick: true,
      ticks: "",
      showticklabels: true,
    },
    yaxis: {
      title: "PC2",
      showgrid: true,
      zeroline: true,
      showline: true,
      autotick: true,

      // show numbers
      showticklabels: true,

      ticks: "",
    },
    showlegend: true,
    legend: {
      x: 0,
      y: 1.0,
      orientation: "h",
      traceorder: "normal",

      font: {
        family: "sans-serif",
        size: 12,
        color: "rgb(0, 0, 0)",
      },
    },
    width: 800,
    height: 600,
    margin: {
      l: 50,
      r: 50,
      t: 50,
      b: 50,
    },
    hovermode: "closest",
    plot_bgcolor: "rgb(255, 255, 255)",
    paper_bgcolor: "rgb(255, 255, 255)",
    font: {
      family: "sans-serif",
      size: 12,
      color: "rgb(0, 0, 0)",
    },
  };

  Plotly.newPlot("plot", data, layout);

  // show the plot
  document.getElementById("plot").style.display = "block";


  document.getElementsByClassName(".app-body-content-text-input-title")[0].style.display = "none";
  document.getElementsByClassName(".app-body-content-text-input")[0].style.display = "none";
}

